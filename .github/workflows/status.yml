name: å®šæœŸã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
permissions:
  contents: write 
on:
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch:

jobs:
  update-status:
    runs-on: [self-hosted, windows]
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
          persist-credentials: true  # â† GitHub ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ credentials ã«æ®‹ã™

      - name: ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼æ¤œå‡ºï¼†çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ï¼†JSONå‡ºåŠ›
        shell: powershell
        run: |
          # ãƒ­ãƒ¼ã‚«ãƒ«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨ã‚µãƒ–ãƒãƒƒãƒˆæƒ…å ±ã‚’å–å¾—
          $interfaces = Get-NetIPAddress -AddressFamily IPv4 | Where-Object { $_.InterfaceAlias -notmatch 'Loopback' -and $_.IPAddress -ne '127.0.0.1' }
          
          # ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°
          function Test-IsComputer {
            param([string]$IPAddress)
            
            # Windowså…±æœ‰ãƒãƒ¼ãƒˆ (445) ãŒé–‹ã„ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            try {
              $tcpClient = New-Object System.Net.Sockets.TcpClient
              $connection = $tcpClient.BeginConnect($IPAddress, 445, $null, $null)
              $wait = $connection.AsyncWaitHandle.WaitOne(100)
              if ($wait) {
                $tcpClient.EndConnect($connection)
                $tcpClient.Close()
                return $true
              } else {
                $tcpClient.Close()
                
                # åˆ¥ã®WinRMãƒãƒ¼ãƒˆ (5985) ã‚‚ãƒã‚§ãƒƒã‚¯
                $tcpClient = New-Object System.Net.Sockets.TcpClient
                $connection = $tcpClient.BeginConnect($IPAddress, 5985, $null, $null)
                $wait = $connection.AsyncWaitHandle.WaitOne(100)
                if ($wait) {
                  $tcpClient.EndConnect($connection)
                  $tcpClient.Close()
                  return $true
                }
                $tcpClient.Close()
                return $false
              }
            } catch {
              return $false
            }
          }
          
          $results = @()
          foreach ($interface in $interfaces) {
            $ip = $interface.IPAddress
            $prefixLength = $interface.PrefixLength
            
            # ã‚µãƒ–ãƒãƒƒãƒˆãƒã‚¹ã‚¯ã‚’è¨ˆç®—
            $mask = [ipaddress]([math]::Pow(2, $prefixLength) - 1 -shl (32 - $prefixLength))
            
            # ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨ˆç®—
            $network = [ipaddress]($ip -band $mask.IPAddressToString)
            $networkStr = $network.IPAddressToString
            
            Write-Host "ã‚¹ã‚­ãƒ£ãƒ³ä¸­ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯: $networkStr/$prefixLength"
            
            # ARP ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰æ—¢çŸ¥ã®ãƒ‡ãƒã‚¤ã‚¹ã‚’å–å¾—
            $arpResults = Get-NetNeighbor -AddressFamily IPv4 | Where-Object { $_.State -eq 'Reachable' -and $_.IPAddress -ne '127.0.0.1' }
            
            foreach ($device in $arpResults) {
              # ã¾ãšã¯Pingã§å¿œç­”ç¢ºèª
              $alive = Test-Connection -Count 1 -Quiet -ComputerName $device.IPAddress
              
              if ($alive) {
                # ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
                $isComputer = Test-IsComputer -IPAddress $device.IPAddress
                
                if ($isComputer) {
                  # ãƒ›ã‚¹ãƒˆåè§£æ±ºã‚’è©¦ã¿ã‚‹
                  try {
                    $hostEntry = [System.Net.Dns]::GetHostEntry($device.IPAddress)
                    $hostname = $hostEntry.HostName
                  } catch {
                    $hostname = "PC-$($device.IPAddress)"
                  }
                  
                  $results += [PSCustomObject]@{
                    name = $hostname
                    ip = $device.IPAddress
                    mac = $device.LinkLayerAddress
                    alive = $alive
                    type = "computer"
                  }
                }
              }
            }
          }
          
          # ç°¡æ˜“ã‚¹ã‚­ãƒ£ãƒ³ã§æ¤œå‡ºã§ããªã‹ã£ãŸã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã‚‚å¯¾è±¡ã«ã™ã‚‹
          $commonComputerIPs = @()
          $startIP = 1
          $endIP = 254
          
          foreach ($interface in $interfaces) {
            $ipParts = $interface.IPAddress -split '\.'
            if ($ipParts.Count -eq 4) {
              $ipBase = "$($ipParts[0]).$($ipParts[1]).$($ipParts[2])."
              for ($i = $startIP; $i -le $endIP; $i++) {
                $testIP = "$ipBase$i"
                # æ—¢ã«æ¤œå‡ºã—ãŸIPã¯é£›ã°ã™
                if (-not ($results | Where-Object { $_.ip -eq $testIP })) {
                  $commonComputerIPs += $testIP
                }
              }
            }
          }
          
          # ã‚µãƒ–ãƒãƒƒãƒˆå†…ã®ä¸€èˆ¬çš„ãªç¯„å›²ã‚’ãƒã‚§ãƒƒã‚¯ (ä¸€éƒ¨ã ã‘ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ãŸã‚)
          $sampleIPs = $commonComputerIPs | Get-Random -Count ([Math]::Min(20, $commonComputerIPs.Count))
          
          foreach ($ip in $sampleIPs) {
            $alive = Test-Connection -Count 1 -Quiet -ComputerName $ip -TimeoutSeconds 1
            if ($alive) {
              $isComputer = Test-IsComputer -IPAddress $ip
              
              if ($isComputer) {
                try {
                  $hostEntry = [System.Net.Dns]::GetHostEntry($ip)
                  $hostname = $hostEntry.HostName
                } catch {
                  $hostname = "PC-$ip"
                }
                
                # MACã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
                $macAddress = "Unknown"
                $arpEntry = Get-NetNeighbor -IPAddress $ip -ErrorAction SilentlyContinue
                if ($arpEntry) {
                  $macAddress = $arpEntry.LinkLayerAddress
                }
                
                $results += [PSCustomObject]@{
                  name = $hostname
                  ip = $ip
                  mac = $macAddress
                  alive = $true
                  type = "computer"
                }
              }
            }
          }
          
          # çµæœã‚’ã‚½ãƒ¼ãƒˆã—ã¦é‡è¤‡ã‚’å‰Šé™¤
          $results = $results | Sort-Object -Property ip -Unique
          
          Write-Host "æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼æ•°: $($results.Count)"
          $results | ConvertTo-Json -Depth 2 | Out-File -Encoding utf8 docs/status.json

      - name: ã‚³ãƒŸãƒƒãƒˆï¼†ãƒ—ãƒƒã‚·ãƒ¥
        shell: powershell
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add docs/status.json
          if (-not (git diff --cached --quiet)) {
            git commit -m "ğŸ“¡ update status.json"
            # ãƒªãƒ¢ãƒ¼ãƒˆ URL ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ä»˜ãã«å·®ã—æ›¿ãˆ
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
            git push origin HEAD:main
          } else {
            Write-Host "No changes to commit."
          }
