name: å®šæœŸã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
permissions:
  contents: write
  actions: write
on:
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch:

jobs:
  update-status:
    runs-on: [self-hosted, windows, self-hosted Windows X64]
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
          persist-credentials: true  # â† GitHub ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ credentials ã«æ®‹ã™
      - name: Set PowerShell Execution Policy
        shell: powershell
        run: |
          Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
      - name: ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼æ¤œå‡ºï¼†çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ï¼†JSONå‡ºåŠ›
        shell: powershell
        run: |
          # ãƒ­ãƒ¼ã‚«ãƒ«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨ã‚µãƒ–ãƒãƒƒãƒˆæƒ…å ±ã‚’å–å¾—
          $interfaces = Get-NetIPAddress -AddressFamily IPv4 | Where-Object { $_.InterfaceAlias -notmatch 'Loopback' -and $_.IPAddress -ne '127.0.0.1' }
          
          # ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°
          function Test-IsComputer {
            param([string]$IPAddress)
            
            # Windowså…±æœ‰ãƒãƒ¼ãƒˆ (445) ãŒé–‹ã„ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            try {
              $tcpClient = New-Object System.Net.Sockets.TcpClient
              $connection = $tcpClient.BeginConnect($IPAddress, 445, $null, $null)
              $wait = $connection.AsyncWaitHandle.WaitOne(100)
              if ($wait) {
                $tcpClient.EndConnect($connection)
                $tcpClient.Close()
                return $true
              } else {
                $tcpClient.Close()
                
                # åˆ¥ã®WinRMãƒãƒ¼ãƒˆ (5985) ã‚‚ãƒã‚§ãƒƒã‚¯
                $tcpClient = New-Object System.Net.Sockets.TcpClient
                $connection = $tcpClient.BeginConnect($IPAddress, 5985, $null, $null)
                $wait = $connection.AsyncWaitHandle.WaitOne(100)
                if ($wait) {
                  $tcpClient.EndConnect($connection)
                  $tcpClient.Close()
                  return $true
                }
                $tcpClient.Close()
                return $false
              }
            } catch {
              return $false
            }
          }
          
          # ã‚µãƒ–ãƒãƒƒãƒˆç¯„å›²ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
          function Get-NetworkRange {
            param(
              [string]$IPAddress,
              [int]$PrefixLength
            )
            
            try {
              # IP ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ãƒã‚¤ãƒˆé…åˆ—ã«å¤‰æ›
              $ipBytes = [System.Net.IPAddress]::Parse($IPAddress).GetAddressBytes()
              [Array]::Reverse($ipBytes)
              $ipInt = [System.BitConverter]::ToUInt32($ipBytes, 0)
              
              # ã‚µãƒ–ãƒãƒƒãƒˆãƒã‚¹ã‚¯ã‚’è¨ˆç®—
              $maskInt = ([UInt32]::MaxValue) -shl (32 - $PrefixLength)
              
              # ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨ˆç®—
              $networkInt = $ipInt -band $maskInt
              
              # ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨ˆç®—
              $broadcastInt = $networkInt -bor (-bnot $maskInt)
              
              # ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å†…ã®æœ€åˆã¨æœ€å¾Œã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
              $startIpInt = $networkInt + 1
              $endIpInt = $broadcastInt - 1
              
              # ã‚¹ã‚¿ãƒ¼ãƒˆ IP ã‚’ãƒã‚¤ãƒˆé…åˆ—ã«å¤‰æ›
              $startIpBytes = [System.BitConverter]::GetBytes($startIpInt)
              [Array]::Reverse($startIpBytes)
              $startIp = [System.Net.IPAddress]::new($startIpBytes)
              
              # ã‚¨ãƒ³ãƒ‰ IP ã‚’ãƒã‚¤ãƒˆé…åˆ—ã«å¤‰æ›
              $endIpBytes = [System.BitConverter]::GetBytes($endIpInt)
              [Array]::Reverse($endIpBytes)
              $endIp = [System.Net.IPAddress]::new($endIpBytes)
              
              return @{
                StartIP = $startIp.IPAddressToString
                EndIP = $endIp.IPAddressToString
              }
            }
            catch {
              Write-Host "IP ç¯„å›²è¨ˆç®—ä¸­ã«ã‚¨ãƒ©ãƒ¼: $_"
              # ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã‚‰ã€ä»£æ›¿ã®å®‰å…¨ãªç¯„å›²ã‚’è¿”ã™
              $ipParts = $IPAddress -split '\.'
              return @{
                StartIP = "$($ipParts[0]).$($ipParts[1]).$($ipParts[2]).1"
                EndIP = "$($ipParts[0]).$($ipParts[1]).$($ipParts[2]).254"
              }
            }
          }
          
          $results = @()
          foreach ($interface in $interfaces) {
            $ip = $interface.IPAddress
            $prefixLength = $interface.PrefixLength
            
            Write-Host "ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹: $($interface.InterfaceAlias), IP: $ip, ã‚µãƒ–ãƒãƒƒãƒˆ: /$prefixLength"
            
            # ARP ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰æ—¢çŸ¥ã®ãƒ‡ãƒã‚¤ã‚¹ã‚’å–å¾—
            $arpResults = Get-NetNeighbor -AddressFamily IPv4 | Where-Object { 
              $_.State -eq 'Reachable' -and $_.IPAddress -ne '127.0.0.1' 
            }
            
            Write-Host "ARP ã‚¨ãƒ³ãƒˆãƒªãƒ¼æ•°: $($arpResults.Count)"
            foreach ($device in $arpResults) {
              # ã¾ãšã¯Pingã§å¿œç­”ç¢ºèª
              try {
                $alive = Test-Connection -Count 1 -Quiet -ComputerName $device.IPAddress -ErrorAction SilentlyContinue
                
                if ($alive) {
                  # ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
                  $isComputer = Test-IsComputer -IPAddress $device.IPAddress
                  
                  if ($isComputer) {
                    # ãƒ›ã‚¹ãƒˆåè§£æ±ºã‚’è©¦ã¿ã‚‹
                    try {
                      $hostEntry = [System.Net.Dns]::GetHostEntry($device.IPAddress)
                      $hostname = $hostEntry.HostName
                    } catch {
                      $hostname = "PC-$($device.IPAddress)"
                    }
                    
                    $results += [PSCustomObject]@{
                      name = $hostname
                      ip = $device.IPAddress
                      mac = $device.LinkLayerAddress
                      alive = $alive
                      type = "computer"
                    }
                    
                    Write-Host "ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼æ¤œå‡º: $hostname ($($device.IPAddress))"
                  }
                }
              } catch {
                Write-Host "ãƒ‡ãƒã‚¤ã‚¹ $($device.IPAddress) ã®ãƒã‚§ãƒƒã‚¯ä¸­ã«ã‚¨ãƒ©ãƒ¼: $_"
                continue
              }
            }
            
            # ã‚µãƒ–ãƒãƒƒãƒˆç¯„å›²ã‚’å–å¾—
            $range = Get-NetworkRange -IPAddress $ip -PrefixLength $prefixLength
            
            # IPç¯„å›²ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ãªIPã‚’é¸æŠã—ã¦ã‚¹ã‚­ãƒ£ãƒ³
            $startParts = $range.StartIP -split '\.'
            $endParts = $range.EndIP -split '\.'
            
            # ç°¡æ˜“çš„ãª IP ãƒªã‚¹ãƒˆã®ç”Ÿæˆï¼ˆã‚µãƒ³ãƒ—ãƒªãƒ³ã‚° - å…¨ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã¯ãªãä¸€éƒ¨ã ã‘ï¼‰
            $ipList = @()
            for ($i = [int]$startParts[3]; $i -le [int]$endParts[3]; $i += 5) {  # 5ã¥ã¤å¢—åŠ ã•ã›ã¦ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
              $ipList += "$($startParts[0]).$($startParts[1]).$($startParts[2]).$i"
            }
            
            # ã‚µãƒ³ãƒ—ãƒ«æ•°ã‚’åˆ¶é™
            $samplesToCheck = $ipList | Get-Random -Count ([Math]::Min(10, $ipList.Count))
            Write-Host "è¿½åŠ ã‚¹ã‚­ãƒ£ãƒ³å¯¾è±¡: $($samplesToCheck.Count) ã‚µãƒ³ãƒ—ãƒ«"
            
            foreach ($ip in $samplesToCheck) {
              # æ—¢ã«æ¤œå‡ºã—ãŸIPã¯é£›ã°ã™
              if ($results | Where-Object { $_.ip -eq $ip }) {
                continue
              }
              
              try {
                $alive = Test-Connection -Count 1 -Quiet -ComputerName $ip -TimeoutSeconds 1 -ErrorAction SilentlyContinue
                if ($alive) {
                  $isComputer = Test-IsComputer -IPAddress $ip
                  
                  if ($isComputer) {
                    try {
                      $hostEntry = [System.Net.Dns]::GetHostEntry($ip)
                      $hostname = $hostEntry.HostName
                    } catch {
                      $hostname = "PC-$ip"
                    }
                    
                    # MACã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
                    $macAddress = "Unknown"
                    $arpEntry = Get-NetNeighbor -IPAddress $ip -ErrorAction SilentlyContinue
                    if ($arpEntry) {
                      $macAddress = $arpEntry.LinkLayerAddress
                    }
                    
                    $results += [PSCustomObject]@{
                      name = $hostname
                      ip = $ip
                      mac = $macAddress
                      alive = $true
                      type = "computer"
                    }
                    
                    Write-Host "è¿½åŠ ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼æ¤œå‡º: $hostname ($ip)"
                  }
                }
              } catch {
                Write-Host "ã‚µãƒ³ãƒ—ãƒ« IP $ip ã®ãƒã‚§ãƒƒã‚¯ä¸­ã«ã‚¨ãƒ©ãƒ¼: $_"
                continue
              }
            }
          }
          
          # çµæœã‚’ã‚½ãƒ¼ãƒˆã—ã¦é‡è¤‡ã‚’å‰Šé™¤
          $results = $results | Sort-Object -Property ip -Unique
          
          Write-Host "æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼æ•°: $($results.Count)"
          $results | ConvertTo-Json -Depth 2 | Out-File -Encoding utf8 docs/status.json
      - name: ã‚³ãƒŸãƒƒãƒˆï¼†ãƒ—ãƒƒã‚·ãƒ¥
        shell: powershell
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add docs/status.json
          if (-not (git diff --cached --quiet)) {
            git commit -m "ğŸ“¡ update status.json"
            # ãƒªãƒ¢ãƒ¼ãƒˆ URL ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ä»˜ãã«å·®ã—æ›¿ãˆ
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
            git push origin HEAD:main
          } else {
            Write-Host "No changes to commit."
          }
